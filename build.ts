import * as fs from 'fs/promises';
import * as path from 'path';
import { spawn } from 'node:child_process';

const production = process.argv.includes('--production');
const watch = process.argv.includes('--watch');
const debug = process.env.BUILD_DEBUG === '1';

function logDebug(message: string) {
  if (debug) console.log(`[build:debug] ${message}`);
}

async function copyMonacoAssets() {
  const src = path.join(process.cwd(), 'node_modules', 'monaco-editor', 'min', 'vs');
  const dest = path.join(process.cwd(), 'dist', 'monaco', 'vs');

  try {
    logDebug('copyMonacoAssets: rm');
    await fs.rm(dest, { recursive: true, force: true });
    logDebug('copyMonacoAssets: mkdir');
    await fs.mkdir(path.dirname(dest), { recursive: true });
    logDebug('copyMonacoAssets: cp');
    await fs.cp(src, dest, { recursive: true });
    logDebug('copyMonacoAssets: done');
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.warn(`[build] Skipping Monaco asset copy: ${message}`);
  }
}

async function generateBundledContent() {
  const sourceRoot = process.cwd();
  const agentsDir = path.join(sourceRoot, '.kanban2code', '_agents');
  const contextsDir = path.join(sourceRoot, '.kanban2code', '_context');
  const modesDir = path.join(sourceRoot, '.kanban2code', '_modes');

  async function readFilesRecursively(baseDir: string, currentDir = baseDir): Promise<Array<{ relativePath: string; content: string }>> {
    const entries = await fs.readdir(currentDir, { withFileTypes: true });
    const files: Array<{ relativePath: string; content: string }> = [];

    for (const entry of entries) {
      if (entry.name.startsWith('.')) {
        continue;
      }
      const entryPath = path.join(currentDir, entry.name);
      if (entry.isDirectory()) {
        files.push(...await readFilesRecursively(baseDir, entryPath));
      } else if (entry.isFile()) {
        const relativePath = path.relative(baseDir, entryPath).split(path.sep).join('/');
        const content = await fs.readFile(entryPath, 'utf-8');
        files.push({ relativePath, content });
      }
    }

    return files;
  }

  async function safeReadFilesRecursively(baseDir: string): Promise<Array<{ relativePath: string; content: string }>> {
    try {
      return await readFilesRecursively(baseDir);
    } catch (error: unknown) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        return [];
      }
      throw error;
    }
  }

  const agentEntries = await safeReadFilesRecursively(agentsDir);
  agentEntries.sort((a, b) => a.relativePath.localeCompare(b.relativePath));
  const bundledAgents: Record<string, string> = {};
  for (const entry of agentEntries) {
    bundledAgents[entry.relativePath] = entry.content;
  }

  const contextEntries = await safeReadFilesRecursively(contextsDir);
  contextEntries.sort((a, b) => a.relativePath.localeCompare(b.relativePath));
  const bundledContexts: Record<string, string> = {};
  for (const entry of contextEntries) {
    bundledContexts[entry.relativePath] = entry.content;
  }

  const modeEntries = await safeReadFilesRecursively(modesDir);
  modeEntries.sort((a, b) => a.relativePath.localeCompare(b.relativePath));
  const bundledModes: Record<string, string> = {};
  for (const entry of modeEntries) {
    bundledModes[entry.relativePath] = entry.content;
  }

  const assetsDir = path.join(sourceRoot, 'src', 'assets');
  await fs.mkdir(assetsDir, { recursive: true });

  const agentsOutput = `// This file is auto-generated by build.ts. Do not edit directly.\n\nexport const BUNDLED_AGENTS: Record<string, string> = ${JSON.stringify(bundledAgents, null, 2)} as const;\n`;
  const contextsOutput = `// This file is auto-generated by build.ts. Do not edit directly.\n\nexport const BUNDLED_CONTEXTS: Record<string, string> = ${JSON.stringify(bundledContexts, null, 2)} as const;\n`;
  const modesOutput = `// This file is auto-generated by build.ts. Do not edit directly.\n\nexport const BUNDLED_MODES: Record<string, string> = ${JSON.stringify(bundledModes, null, 2)} as const;\n`;

  await fs.writeFile(path.join(assetsDir, 'agents.ts'), agentsOutput);
  await fs.writeFile(path.join(assetsDir, 'contexts.ts'), contextsOutput);
  await fs.writeFile(path.join(assetsDir, 'modes.ts'), modesOutput);
}

function runEsbuild(args: string[]): Promise<void> {
  const esbuildBin = path.join(
    process.cwd(),
    'node_modules',
    '@esbuild',
    'linux-x64',
    'bin',
    'esbuild',
  );

  return new Promise((resolve, reject) => {
    logDebug(`esbuild ${args.join(' ')}`);
    const child = spawn(esbuildBin, args, { stdio: 'inherit' });
    child.on('error', reject);
    child.on('close', (code) => {
      if (code === 0) resolve();
      else reject(new Error(`esbuild exited with code ${code ?? 'unknown'}`));
    });
  });
}

const commonArgs: string[] = [];
if (!production) commonArgs.push('--sourcemap');
if (production) commonArgs.push('--minify');

const extensionArgs = [
  'src/extension.ts',
  '--bundle',
  '--platform=node',
  '--format=cjs',
  '--external:vscode',
  '--outfile=dist/extension.js',
  ...commonArgs,
  ...(watch ? ['--watch'] : []),
];

const webviewArgs = [
  'src/webview/ui/main.tsx',
  '--bundle',
  '--platform=browser',
  '--format=iife',
  '--outfile=dist/webview.js',
  ...commonArgs,
  ...(watch ? ['--watch'] : []),
];

if (watch) {
  logDebug('watch mode');
  await generateBundledContent();
  await copyMonacoAssets();
  await Promise.all([
    runEsbuild(extensionArgs),
    runEsbuild(webviewArgs),
  ]);
} else {
  logDebug('build start');
  await generateBundledContent();
  await Promise.all([
    runEsbuild(extensionArgs),
    runEsbuild(webviewArgs),
  ]);
  logDebug('build done');
  await copyMonacoAssets();
}
